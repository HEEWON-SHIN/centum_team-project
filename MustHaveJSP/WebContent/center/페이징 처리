

게시물 페이지 번호 처리(페이징 처리)

	설명 : 게시물이 몇 개 없을 때는 상관없지만, 게시물이 많아지면 한 화면에 모든 게시물을 출력하면 가독성이 떨어진다.
		  서비스가 인기를 끌어 게시물이 1만개가 된다고 가정해보면 다음과 같은 문제가 발생한다.
		  
		  	문제1. 스크롤이 길어져서 사용자가 글목록에서 원하는 게시물을 찾기가 어렵다.(가독성 저하)
		  	문제2. 전송해야할 데이터가 많아지므로 페이지 로딩 속도가 느려진다.
		  	문제3. 한꺼번에 많은 데이터를 조회해서 처리해야 하므로 데이터베이스에도 과부하가 걸린다.
		  
		  그래서 게시판에서는 목록을 보통 10~20개 정도씩 나눠서 페이지별로 조회해서 출력한다.
		  이런 기법을 페이징이라고 한다.
	  
	  
	1.	페이징 처리를 위한 설정 두가지
		
			1. 한 페이지에 출력할 게시물의 갯수
				POSTS_PER_PAGE = 10;(10개씩 보여주기 위해 변수에 10 저장)
				
			2. 한 화면에 출력할 블록 갯수를 설정(prev 1 2 3 4 5 next 부분을 한 블럭으로 묶음)
				PAGES_PER_BLOCK = 5;
			
	
		2. 페이징 구현 절차 6단계
		
			1단계. board테이블에 저장된 전체 레코드 수를 카운트한다.
					예) 전체 게시물이 105개라 가정한다.
					
			2단계. 각 페이지에 출력할 게시물의 범위를 계산한다.	
					예) 범위의 시작 : (현재 페이지 -1) * POSTS_PER_PAGE + 1
					    범위의 종료 : (현재 페이지 * POSTS_PER_PAGE)
					    
					    계산 : 현재 1페이지일 때
					    		범위의 시작값 : (1-1) * POSTS_PER_PAGE + 1 => 1이 나옴
					    		범위의 종료값 : 1 * POSTS_PER_PAGE => 10이 나옴
					    			=> 1~10번 글까지는 1페이지에서 보여줌
					    	
							  현재 2페이지일 때
							  	  	범위의 시작값 : (2-1) * POSTS_PER_PAGE + 1 => 11이 나옴
					    			범위의 종료값 : 2 * POSTS_PER_PAGE => 20이 나옴
					    				=> 11~20번 글까지는 2페이지에서 보여줌
					    				
					    			
			3단계. 전체 페이지의 수,, 이 때 계산된 결과는 무조건 올림처리 한다. 만약 올림처리 하지 않으면 마지막 페이지의 게시물 수 5개는 조회할 수 없기 때문이다.
			
					계산식 : Math.ceil( 전체게시물 수 / POSTS_PER_PAGE )
								참고로 Math.ceil()메소드는 소수점 첫째자리에서 올림 해주는 메소드이다
								
						예) 글 105개 -> 한 페이지에 10개씩 -> 즉, 총 11개의 페이지 번호가 필요함
							Math.ceil( 105 / POSTS_PER_PAGE ) => Math.ceil( 10.5 ) => 11
							
							
			
			4단계. 이전 페이지 블록 바로가기를 출력한다.
			
				계산식 : ( (현재 페이지 -1 ) / PAGES_PER_BLOCK ) * PAGES_PER_BLOCK + 1
				
						참고로! (현재 페이지 -1 ) / PAGES_PER_BLOCK 하면 몫만 값으로 가진다.(수학식 아님!)
				
				
					예) 현재 1페이지일 때
						pageTemp = ( (1 - 1) / PAGES_PER_BLOCK ) * PAGES_PER_BLOCK +1 => 1 
						
						현재 5페이지일 때
						pageTemp = ( (5 -1) / PAGES_PER_BLOCK ) * PAGES_PER_BLOCK +1 => 1?
										
						
						=> pageTemp변수가 1이라는 것은 첫번째 페이지 블록을 뜻하므로
						   이전 페이지 블록 바로가기(prev)를 출력하지 않는다.
				
						현재 6페이지일 때
						pageTemp = ( (6 -1) / PAGES_PER_BLOCK ) * PAGES_PER_BLOCK +1 => 6
						
						현재 10페이지일 때
						pageTemp = ( (10 -1) / PAGES_PER_BLOCK ) * PAGES_PER_BLOCK +1 => 6?
						
						1이 아닐 때는 pageTemp -1 결과로 이전 페이지 블록 바로가기를 출력한다.
						즉, 이전 페이지 블록은 5가 된다.
						
						
				5단계. 각 페이지 번호를 출력한다.
					  4단계에서 계산한 pageTemp를 BLOCK_PAGE만큼 반복하면서 +1 연산 후 출력한다.
					  
					  	예) pageTemp가 1일 때 : "1 2 3 4 5" 출력
					  		pageTemp가 6일 때 : "6 7 8 9 10" 출력
					  		
					  	
				6단계.  다음페이지 블록 바로가기를 출력한다.
				
					각 페이지 번호를 출력한 후 pageTemp +1 하여 다음 페이지 블록 바로가기를 설정한다.
					즉, 마지막 페이지 번호가 5라면 다음 페이지 블록 시작은 6이 된다.
				
			
			
			
	3. 페이징용 쿼리문 작성하기
	
		  2.페이징 구현 절차 6단계 에서 게시물을 카운트하여 각 페이지에서 출력할 게시물의 갯수 범위를 계산했다.
		  계산된 결과에서 범위의 시작값과 끝 값을 구했는데, 이 값을 이용해 쿼리문(SELECT문)을 작성한다.
		  우리가 사용하는 DBMS는 오라클이므로 rownum 가상열을 이용해서 쿼리문을 작성한다.
		  	rownum이란?
		  		- 오라클에서 생성된 모든 테이블에서 사용할 수 있는 가상의 컬럼(열)로,
		  		  SELECT쿼리문으로 검색하는 데이터에 순차적으로 부여되는 번호를 말한다. 
		  		  rownum은 물리적으로 존재하는 컬럼이 아니므로 값을 변경하기 위한 DML문을 사용할 수 없다.
		  		  
		  		  	참고로 DML은 데이터 조작어(INSERT, UPDATE, DELETE, SELECT)를 말한다.
		  		  	
		  		  sqlDeveloper툴을 이용해 실습!
		  		  
		  		  	1. musthave계정으로 접속
		  		  	2. member테이블 구조 확인 (desc member;)
		  		  	3. SELECT문에 ID, PASS컬럼을 지정하고 rownum열도 지정해서 조회
		  		  		(SELECT ID, PASS, ROWNUM FROM MEMBER;)
		  		  		
		  		  		결과 : rownum이라는 열(컬럼)은 만든적이 없는데, 조회된 결과를 보면 순번이 조회가 되어 출력된다.
		  		  		
		  페이징 처리용 쿼리문(SELECT) 작성
		  	-> 첫번째 페이지에서 조회되어 출력될 게시물을 DB에서 가져오기 위해 
		  		rownum을 1~10까지로 지정했다. rownum으로 부여한 번호를 이용해 
		  		첫번째 페이지에 rownum번호 1~10번까지의 글(96~105번글)을 띄울 수 있다.
		  		
		  		BETWEEN 대신에 rNUM >=1 과 같이 조건을 줄 수도 있다.
		  		
		  		
		  	SELECT * FROM (														
		  	
		  		SELECT Tb.*, ROWNUM AS rNUM 
		  			
		  				FROM (	SELECT * FROM board ORDER BY NUM DESC) Tb
		  	
		  		) 	WHERE rNUM BETWEEN 1 AND 10; //1~10번 글 보여줌?
		  		
		  			
		  	-------------------------------------------------------------------------------------------
		  	
		  	SELECT * FROM (														<--3번								
		  	
		  		SELECT Tb.*, ROWNUM AS rNUM 									<--2번
		  			
		  				FROM (	SELECT * FROM board ORDER BY NUM DESC) Tb		<--1번
		  	
		  		) 	WHERE rNUM BETWEEN 1 AND 10;	  	
		  	
		  	
		  	
		  	1번 : (SELECT * FROM board ORDER BY NUM DESC) Tb
		  		=> board테이블에 저장된 모든 게시물을 글번호(num)을 기준으로 해서 내림차순 정렬로 조회
		  		
		  	2번 : SELECT Tb.*, ROWNUM AS rNUM FROM (1번) Tb
		  		=> 1번 쿼리문의 조회된 결과 행을 Tb.*을 통해 모두 조회해서 가져오고,
		  		   rownum의 별칭을 rNUM으로 줘서 1번과 rNUM을 조회
		  		   이 때, 가장 최신글(105번 글)의 rownum이 1번이 되게 된다.
		